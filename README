
$Id: README,v 1.7 2005/04/13 20:13:47 jimg Exp $

For information about building the DODS netCDF 3 source code, see the INSTALL
file.

This file provides basic information about the DODS netCDF server and its
configuration. For more detailed information, see the Server Installation
Guide at http://www.unidata.ucar.edu/packages/dods/user/install-html/.

The information that follows is mostly up to date, but the Server Install
Guide is probably a better source of information for most users.

----------------------------------------------------------------------------

This file contains information about the DODS-netCDF software. For information
about building and using the software, see the files INSTALL and USING. For
information about secure servers (that limit access to domains or individual
people) see the file SECURITY.

The Distributed Oceanographic Data System (DODS) allows you to access local
and/or remote data sets without the need for format conversion or changes
to the original software. Instead, existing software can be rebuilt using 
the DODS replacements for certain standard components. This rebuilt would make
the software into a DODS client which can now communicate with DODS servers.

DODS also makes it simple to provide others with direct, over-the-network,
access to your data. There is no need to reformat your data so that a new
system can read it. Instead DODS uses the http server along with a dispatch 
script and a set of three server programs (Data Attribute Server, Data 
Structure Server, and Data Server) to make your existing data files available
to anyone who has access to a program rebuilt with DODS components.

For more information about OPeNDAP and DODS, see the URL

    http://www.opendap.org/

nc-dods is a client-server implementation of the Unidata netCDF API, based on
the Distributed Oceanographic Data System. nc-dods contains a new
implementation of the netCDF library which can be linked with programs which
currently are built with the standard implementation of the API. In addition,
the software also contains a matching data server which can be used along
with the client library.

The replacement library included in the nc-dods distribution mirrors the
standard implementation of the netCDF API very closely. A variety of software
packages have been developed for netCDF data display and analysis; rebuilding
these packages with nc-dods library instead of the original netCDF library
makes them capable of accessing data over the network through the provided
server software. The user can refer to the entire remote dataset using a URL
instead of the local file name. Furthermore, if the user wants to work only
with a small part of the data set, a constraint expression can be supplied
along with the URL to save on network data transmition time.

The current nc-dods client software supports the C programming interface 
and the Fortran Jacket of the netCDF for UNIX platform.

You can obtain a copy of the latest version of nc3-dods software from
http://unidata.ucar.edu/packages/dods/.

Included in this distribution are: 

 - The netCDF surrogate client library,
 - The Fortran jacket for the netCDF surrogate library,
 - server programs and their dispatch script (nc-dods, nc-das, nc-dds, nc),
 - ncdump and ncview programs rebuilt with nc-dods client library, 
 - test programs, and documentation.

RELINKING USER SOFTWARE

To re-link an existing program with the DODS implementation of netCDF, you do
just that. Find the directory that contains the source code and modify the
Makefile for the program so that in place of the netCDF library the DODS
library is used. Because DODS is implemented as a core set of classes
that are then specialized for each re-implemented API, the re-linking
of a program involves several libraries.  These libraries are:

	libdap++.a:	 The core software
	libnc-dods.a:	 The software special to the netCDF implementation

Once built and installed, these libraries will be in the lib/
directory.  The required header files should be in include/.  There
are quite a few header files that come with the libdap++.a library.
Only netcdf.h comes with the libnc-dods.a, it is the standard netCDF
header file (you should not need to change your netCDF application).

Also used by DODS are the World Wide Web library from the Web Consortium, Tcl
from Sun Labs and Expect from NIST. These libraries are all freely available
(you can get either source of binary versions from our ftp site or the
`official' site - see http://www.unidata.ucar.edu/packages/dods/home/sw.html).
The World Wide Web library is required by DODS while the Tcl and Expect
libraries are not.

Look in the Makefile in this directory to see how we re-linked the netCDF
programs `ncdump' and `ncview'. When using g++ a program can be re-linked
without explicitly including libg++.a on the command line:

	-lnc-dods -ldap++ -lcurl -lrx -lz

Once re-linked, the program will work exactly as before when run using local
files. However, users can also give URLs to specify data files. In this case
the machine name part of the URL must reference a machine which has data
accessible via a DODS data server (see SETTING UP A DATA SERVER). Suppose
that a friend has told you about a data file named `buoys.nc' in a directory
called `exp1' on a machine named oceans.univ.edu. To look at this data invoke
ncdump using the URL for this data in place of a simple filename. E.G.:

       ncdump http://dods.gso.uri.edu/cgi-bin/nph-nc/data/fnoc3.nc

       ^^^^^^        ^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^ ^^^^ ^^^^^^^^ 
       Program	     Machine name     Server         Dir  File     
	      
And to look at the first 10 elements of an array vairable named `u' in this
data file, you can use a constraint as a URL parameter. E.G.:

       ncdump http://dods.gso.uri.edu/cgi-bin/nph-nc/data/fnoc3.nc?u[0:9]

       ^^^^^^        ^^^^^^^^^^^^^^^^ ^^^^^^^^^^^^^^ ^^^^ ^^^^^^^^ ^^^^^^
       Program	     Machine name     Server         Dir  File     Constraint
	      
Note that the URL to data/fnoc3.nc is accessed via the data server which is
an http CGI module. You need to tell the http daemon to run the DODS data
server and read from the named file (in this case data/fnoc3.nc). That is why
the `cgi-bin/nph-nc' part is in the URL.

SETTING UP A DATA SERVER

Note: this discussion assumes that the NCSA World Wide Web server (httpd) is
installed on the workstation which is to be used to serve data. You do not
need to use this particular web server, any server that supports CGI 1.1
(Netscape, Apache, CERN, ...) will work. If you not have a web server
installed, first install one and then continue installing the DODS server.
For information on various servers, see: 

NCSA		http://hoohoo.ncsa.uiuc.edu/
Apache		http://www.apache.org/
CERN/W3C	http://www.w3c.org/

To set up a DODS data server using the netCDF server implementation, first
follow the instructions in the INSTALL document. Four programs comprise the
data server: a CGI (nph-nc) which is used to dispatch each data request to the
correct filter program and three filter programs (nc_das, nc_dds,
nc_dods). Make sure that the CGI module `nph-nc' is somewhere where the http
server can run CGI modules. 

Data that are to be served by the DODS server must either be within the http
server's document root directory or they must be in files/directories that
are linked to files/directories within the document root directory. To find
out which directory is the http server's document root, look in the httpd
configuration file srm.conf.

For example, to make the file test.nc available to users it must be either
placed or linked within the document root directory. On my workstation
the document root directory is /usr/local/spool/http so the file must be
moved or copied to that directory or one of its subdirectories or I must
create a symbolic link in that directory or one of its subdirectories to the
file. I have created a directory `data' in the http server's document root
directory and copied the file test.nc there. The URL to that data file is:

	  http://dods.gso.uri.edu/cgi-bin/nph-nc/data/test.nc

Note that after the machine name (dods.gso.uri.edu) the URL contains the path
to the DODS data server CGI and that the path to the data (relative to the
document root directory) *follows* the CGI name.

Also note that to limit access to the server to a specific set of machines,
place the CGI within the document root directory (this works for NCSA version
1.5 and later and also for Apache 1.1.1 and later). See the file SECURITY for
a detailed description of the types of security DODS provides for data and
how to install servers to take advantage of those features.

Good Luck :-)
Reza Nekovei, URI

NETCDF CLIENT-LIBRARY DESIGN INFORMATION

Compile time constants

DEFAULT_BASETYPE_FACTORY

With version 3.5 of libdap++, the creation of variable is controled by a
factory class. The default factory is name BaseTypeFactory; the netCDF CL
uses a factory named NCTypeFactory to instamtiate NCByte, et cetera. However,
some functions of the libdap++ library which take a pointer to a
BaseTypeFactory can still be called without passing this pointer is the
symbol DEFAULT_BASETYPE_FACTORY is defined. The 3.5 version of libdap++ is
built this way and defining this symbol while building this code is
recommended.

STRING_AS_ARRAY

If the compile-time constant STRING_AS_ARRAY is defined, then OPeNDAP
strings will be translated into netCDF character arrays. This symbol is
defined as 1 in nc_util.h, thus is is the default behavior. Also by default
the size of the string arrays is set to 128 characters using the symbol
STRING_ARRAY_SIZE, also defined in nc_util.h.

Both DEFAULT_BASETYPE_FACTORY and STRING_AS_ARRAY only need to be defined
when building the library; there's no need to define them when compiling
software that uses the library or when linking to the library.

How to use the enhanced features of the library

For most data sources, there's no need to do anything differently with this
version of the library. Previous versions could not process data sources
which contained Structures or Sequences. For data sources with Structures,
those are flattened by the 3.5 version of the library. A Structure like:
      
      Structure {
	  Float32 lat;
	  Float32 lon;
      } point;

will be represented by the netCDF CL as 

      Float32 point.lat;
      Float32 point.lon;

Note that the dot (.) is part of the name of two new variables.

For Sequences the flattening operation is a little more complex because a
Sequence represents a series of values. Suppose 'point' above was a Sequence
and not a Structure:

      Sequence {
	  Float32 lat;
	  Float32 lon;
      } point;

then it might* be represented:

      Float32 point.lat[point=100];
      Float32 point.lon[point=100];

In this case the two fields lat and lon have been transformed in to arrays.
Each of the arrays holds the set of instances that make up the Sequence
values for 'point'. 

*This _might_ be the representation because there maybe more of less than 100
element s in the Sequence point. This value is controled using a 'URL
parameter' that will be discussed inthe next section.

One limitation of version 3.5 of the netCDF CL is that it cannot handle
'nested Sequences.' That is, if a Sequence holds another Sequence, directly
or indirectly, the inner Sequence(s) will be elided. If this happens a Global
attribute will be added to the data source noting that this has happened and
giving the name of the variable(s) that was/were removed.

Also note that any variable that is the result of a translation operation will
have an additional 'translation' attribute that names the translation
algorithm applied to that variable. In version 3.5 of the library, only the
'flatten' algorithm is supported.

Using the new features of the library

The library will translate Sequences into one-element arrays by default. Not
very useful, but also not expensive in terms of memory. The change the
default to another value using the URL parameter 'limit' with a numeric value
like 100. The syntax of the URL parameters is '[limit=<<value>>]'. To affect
a change in the size of a particular variable use '[limit-<<name>>=<<value>>]'.

There's currently no way to alter the behavior of the string translation. All
String variables in OPeNDAP data sources are translated into 128 character
arrays whos dimension is named <<varname>>-chars.

In all cases the new array's dimensions are named and are part of the data
source's dimensions accessible through the netCDF CL API.

NetCDF places a soft limit on the number of dimensions at 100. Because there
are potentially many more than the 100 dimensions in a translated file, this
limit has been increased to 1024. Several other constants defined by the
netCDF library have been changed, here's a list along with their new values:

    NC_MAX_DIMS     1024     /* max dimensions per file */
    NC_MAX_ATTRS    4096     /* max global or per variable attributes */
    NC_MAX_VARS     4096     /* max variables per file */
    NC_MAX_NAME     1024      /* max length of a name */

These are defined in the netcdf.h header that comes with the netCDF CL.
Because of this change, you should probably recompile you program using the
new header. In the past it was possible to relink a program that had already
been compiled. That is still possible, but many OPeNDAP data sources,
especially those serving data stored in HDF-EOS files, will exceed the
default limits of the original netCDF library (whose values are compiled into
your program). Your program will probably exhibit strange behavior when
looking at those data sources unless you recompile with our netCDF CL header.

Files and their function

Basic operation of the netCDF CL

The library works by replacing the functionality of the netCDF API's read
functions with versions that are capable of reading from DAP-compatible
servers. The ncopen() function call has been replaced with a version which
creates an instance of NCConnect; NCConnect holds information about the
remote data source that enables the remaining functions to return information
using minimal interactions with the remote server.

See the figure/file netCDF_CL_containers

The class NCConnect subclasses the libdap++ class Connect. The new behavior
introduced by NCConnect reads a constrained DDS from the target data source
and then passes that DDS through a translation process. The netCDF maintains
a container Connections which holds an array of MAX_CONNECTIONS (see
Connections.h). Each NCConnect instance is added to the Connections array and
is indexed using the cdfid (the cdfid is returned to the netCDF application
by ncopen)).

NCConnect does some other things in addition to reading the constrained DDS
and generating the translated DDS. Look at NCConnect::init_remote_source().

Note that all data sources are translated. If there's no change in the
representation of the data source, the translated DDS is a copy of the
constrained DDS. A decent optimization would be to eliminate the translation
step in cases where it's not needed.

The class ClientParams is used to parse the 'URL parameters' passed to teh CL
as a prefix to the URL.

The nc_util.cc file contains utility functions. The most important of these
are DODvario() and GenRead(). DODvario() reads the values for a single
variable. It uses capabilities added to the type classes (NCByte, ...,
NCGrid). GenRead calls DODvario and then performs some data rearragement to
optimize accesses (i.e., I don't really follow what GenRead does, but it
works and, the important point, DODvario is the only place where data values
are read from a remote server).

How DODvario() works

First DODvario() uses NCConnect::get_variable(varid) to get the variable
(referenced using a BaseType*) from the translated DDS. If the variable was
translated (determined using the NCAccess::get_source() method) the server
version and projection part of the CE are stored in the variable (using two
of the methods in NCAccess). Note: the NC type classes inherit from both
NCAccess and the libdap++ type classes, See figure/file netCDF_CL.ps.
Once the server version and projection CE are stored in the source variable,
the NCAccess::build_constraint() method is used to build an appropriate
constraint.

If the variable was not the product of translation (i.e.,
NCAccess::get_source() returned null indicating there's no 'source variable'
for the current variable), the same methods are called, but using the
variable (BaseType*) straing from the translated DDS.  

How this works: If a variable appears to be a array in the translated DDS, it
might really be an array (because it was just copied from the constrained DDS
because no translation was required), a string, a structure of arrays or a
sequence. Each of thype can specialize NCAccess::build_constraint() so that
the projection CE information is used to build a correct CE to send to the
server. Look at NCArray::build_constraint() and
NCSequence::build_constraint() to see how this works. Also not that the
server version has to be passed because of a bug in Sequence range requests
in the 3.4 and earlier servers.

DODvario() then builds the complete CE by concatenating the selction part of
the CE with the projection CE returned from build_constraint(). This is then
used to request data.

When the data values come back they are stored in a new DDS (a DataDDS
really) and this DDS is not translated. Instead the name of the variable
(which will include dots if it was translated) is used to find the BaseType*
which references the variable holding the returned values. Once found the
NCAccess::extract_values() method is used to mve the values from the
BaseType* into the void *values formal parameter (a formal parameter of
DODvario). Each of the type classes can specialize extract_values().


